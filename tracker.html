<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Споживання по категоріях</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
  <style>
    :root {
      --bg: #111;
      --panel: #1a1a1a;
      --text: #eee;
      --muted: #444;
      --btn: #555;
      --btn-hover: #777;
      --accent: rgb(75,192,192);
    }
    body { font-family: Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; }
    .container { max-width: 1200px; margin: auto; }
    .dataset { border: 1px solid var(--muted); border-radius: 8px; padding: 15px; margin-bottom: 25px; background: var(--panel); }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid var(--muted); padding: 8px; text-align: center; }
    input, button { padding: 6px; margin: 2px; border-radius: 4px; border: 1px solid var(--muted); }
    input[type="date"], input[type="number"], input[type="text"] { background: #222; color: var(--text); }
    button { cursor: pointer; background: var(--btn); color: #fff; }
    button:hover { background: var(--btn-hover); }
    .chart-wrap { position: relative; width: 100%; height: 400px; margin-top: 10px; }
    canvas { width: 100% !important; height: 100% !important; display: block; }
    .controls button { margin: 0 2px; }
    .stats { margin: 8px 0; padding: 6px; background: #222; border-radius: 6px; font-size: 14px; }
    @media (max-width: 768px) { th, td { font-size: 12px; } .chart-wrap { height: 260px; } }
  </style>
</head>
<body>
<div class="container">
  <h1>Споживання по категоріях</h1>
  <div id="datasets"></div>
  <div>
    <input type="text" id="newCategory" placeholder="Назва нової категорії (напр. Газ)" />
    <button onclick="addDataset()">Додати категорію</button>
  </div>
</div>

<script>
let datasets = [];

function addDataset() {
  const name = document.getElementById('newCategory').value.trim();
  if (!name) return;
  datasets.push({ name, entries: [], chart: null, barChart: null, collapsed: false });
  document.getElementById('newCategory').value = '';
  renderDatasets();
}

document.getElementById('newCategory').addEventListener('keydown', function(event) {
  if (event.key === 'Enter') {
    event.preventDefault();
    addDataset();
  }
});

function toggleCollapse(i) {
  datasets[i].collapsed = !datasets[i].collapsed;
  renderDatasets();
}

function addEntry(i) {
  const today = new Date().toISOString().slice(0,10);
  datasets[i].entries.push({ date: today, value: 0 });
  renderDatasets();
}

function updateEntry(i, j, field, value) {
  datasets[i].entries[j][field] = field === 'value' ? Number(value) : value;
  renderDatasets();
}

function deleteEntry(i, j) {
  datasets[i].entries.splice(j, 1);
  renderDatasets();
}

function moveEntry(i, j, dir) {
  const arr = datasets[i].entries;
  if (dir === -1 && j > 0) [arr[j-1], arr[j]] = [arr[j], arr[j-1]];
  if (dir === 1 && j < arr.length-1) [arr[j+1], arr[j]] = [arr[j], arr[j+1]];
  renderDatasets();
}

function exportCSV(i) {
  const rows = [['category','date','value'], ...datasets[i].entries.map(e => [datasets[i].name, e.date, e.value])];
  const csv = rows.map(r => r.join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${datasets[i].name}.csv`;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
}

function importCSV(event, i) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    const lines = e.target.result.split(/\r?\n/).filter(Boolean).slice(1);
    const entries = lines.map(line => {
      const [category, date, value] = line.split(',');
      return { date: (date || '').trim(), value: Number(value) };
    }).filter(r => r.date);
    datasets[i].entries = entries;
    datasets[i].collapsed = true; // Collapse after import
    renderDatasets();
    event.target.value = '';
  };
  reader.readAsText(file);
}

function pickTimeUnit(minDate, maxDate) {
  const spanDays = (maxDate - minDate) / 86400000;
  if (spanDays <= 7) return 'day';
  if (spanDays <= 90) return 'week';
  if (spanDays <= 730) return 'month';
  return 'year';
}

function drawChart(i) {
  const ctx = document.getElementById(`chart-${i}`).getContext('2d');
  if (datasets[i].chart) datasets[i].chart.destroy();

  const sorted = [...datasets[i].entries].filter(e => e.date).sort((a,b) => new Date(a.date) - new Date(b.date));

  if (!sorted.length) return;

  // Color palette for years
  const yearColors = [
    '#e74c3c', '#3498db', '#2ecc71', '#f39c12',
    '#9b59b6', '#1abc9c', '#e67e22', '#34495e',
    '#16a085', '#c0392b', '#2980b9', '#8e44ad'
  ];

  // Group entries by year
  const yearGroups = {};
  sorted.forEach(e => {
    const year = e.date.slice(0, 4);
    if (!yearGroups[year]) yearGroups[year] = [];
    yearGroups[year].push(e);
  });

  const years = Object.keys(yearGroups).sort();
  const chartDatasets = [];
  const yearBaselines = {}; // Store baseline for stats calculation

  // Reference year for overlaying (we'll normalize all dates to 2000)
  const REFERENCE_YEAR = 2000;

  // Calculate baseline for each year and create datasets
  years.forEach((year, yearIndex) => {
    let baseline = 0;

    if (yearIndex === 0) {
      // First year: use first entry as baseline
      baseline = yearGroups[year][0].value;
    } else {
      // Subsequent years: interpolate Jan 1 value from previous year's last entry
      const prevYear = years[yearIndex - 1];
      const prevYearEntries = yearGroups[prevYear];
      const lastPrevEntry = prevYearEntries[prevYearEntries.length - 1];
      const firstCurrEntry = yearGroups[year][0];

      const lastPrevDate = new Date(lastPrevEntry.date);
      const firstCurrDate = new Date(firstCurrEntry.date);
      const jan1 = new Date(`${year}-01-01`);

      // Interpolate value at Jan 1
      const totalDays = (firstCurrDate - lastPrevDate) / (24 * 60 * 60 * 1000);
      const daysToJan1 = (jan1 - lastPrevDate) / (24 * 60 * 60 * 1000);

      if (totalDays > 0 && daysToJan1 >= 0) {
        const rate = (firstCurrEntry.value - lastPrevEntry.value) / totalDays;
        baseline = lastPrevEntry.value + (rate * daysToJan1);
      } else {
        baseline = firstCurrEntry.value;
      }
    }

    yearBaselines[year] = baseline;

    // Create dataset for this year with zeroed values
    // Normalize dates to reference year (keep only month-day)
    const points = yearGroups[year].map(e => {
      const monthDay = e.date.slice(5); // Get MM-DD
      return {
        x: `${REFERENCE_YEAR}-${monthDay}`,
        y: e.value - baseline
      };
    });

    // Add Jan 1 point at 0 for visual consistency
    points.unshift({ x: `${REFERENCE_YEAR}-01-01`, y: 0 });

    chartDatasets.push({
      label: year,
      data: points,
      borderColor: yearColors[yearIndex % yearColors.length],
      backgroundColor: yearColors[yearIndex % yearColors.length],
      fill: false,
      tension: 0.15,
      pointRadius: 3,
      borderWidth: 2,
      spanGaps: false
    });
  });

  // Set x-axis to span Jan 1 to Dec 31 of reference year
  const xMin = new Date(`${REFERENCE_YEAR}-01-01`);
  const xMax = new Date(`${REFERENCE_YEAR}-12-31`);

  datasets[i].chart = new Chart(ctx, {
    type: 'line',
    data: { datasets: chartDatasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: 'time',
          time: {
            unit: 'month',
            displayFormats: {
              month: 'MMM'
            }
          },
          min: xMin,
          max: xMax,
          grid: { color: '#2b2b2b' },
          title: { display: true, text: 'Місяць', color: '#ddd' }
        },
        y: {
          beginAtZero: true,
          grid: { color: '#2b2b2b' },
          title: { display: true, text: 'Відносне споживання', color: '#ddd' }
        }
      },
      plugins: {
        legend: {
          labels: { color: '#ddd', font: { size: 12 } },
          display: true
        },
        tooltip: {
          callbacks: {
            title: function(context) {
              // Show actual month/day in tooltip
              const date = new Date(context[0].parsed.x);
              const month = date.toLocaleString('uk-UA', { month: 'long' });
              const day = date.getDate();
              return `${day} ${month}`;
            }
          }
        }
      }
    }
  });

  drawBarChart(i, sorted);
  updateStats(i, sorted, yearGroups, yearBaselines);
}

const deltaArrowsPlugin = {
  id: 'deltaArrows',
  afterDatasetsDraw(chart) {
    const { ctx } = chart;
    const meta = chart.getDatasetMeta(0);
    const data = chart.data.datasets[0]?.data || [];
    if (!meta || !meta.data?.length) return;

    // Use the x scale bottom instead of chartArea.bottom
    const xScale = chart.scales[meta.xAxisID || meta.xScaleID || 'x'];
    if (!xScale) return;
    const baseY = xScale.bottom + 4; // push arrows below tick labels

    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = '12px Arial';

    for (let i = 1; i < data.length; i++) {
      const curr = Number(data[i]);
      const prev = Number(data[i - 1]);
      const el = meta.data[i];
      if (!el) continue;

      let label = '—';
      let color = '#999';

      if (isFinite(curr) && isFinite(prev) && prev !== 0) {
        const pct = ((curr - prev) / prev) * 100;
        const up = pct >= 0;
        const arrow = up ? '↑' : '↓';
        color = up ? '#e74c3c' : '#2ecc71';
        label = `${arrow} ${pct >= 0 ? '+' : ''}${Math.round(pct)}%`;
      }

      ctx.fillStyle = color;
      ctx.fillText(label, el.x, baseY);
    }

    ctx.restore();
  }
};

function drawBarChart(i, sorted) {
  const barContainer = document.getElementById(`bar-container-${i}`);
  if (!barContainer) return;

  // Clear existing charts
  barContainer.innerHTML = '';
  if (!sorted.length) return;

  // Color palette (same as line chart)
  const yearColors = [
    '#e74c3c', '#3498db', '#2ecc71', '#f39c12',
    '#9b59b6', '#1abc9c', '#e67e22', '#34495e',
    '#16a085', '#c0392b', '#2980b9', '#8e44ad'
  ];

  // Group by year
  const yearGroups = {};
  sorted.forEach(e => {
    const year = e.date.slice(0, 4);
    if (!yearGroups[year]) yearGroups[year] = [];
    yearGroups[year].push(e);
  });

  const years = Object.keys(yearGroups).sort().reverse(); // newest first

  // Create a bar chart for each year
  years.forEach((year, yearIndex) => {
    const yearEntries = yearGroups[year];
    const entries = yearEntries.map(e => ({
      date: new Date(e.date),
      day: e.date.slice(8, 10),
      month: e.date.slice(0, 7),
      value: e.value
    }));

    // Calculate monthly consumption
    const monthTotals = {};
    for (let k = 0; k < entries.length - 1; k++) {
      const a = entries[k];
      const b = entries[k + 1];
      const diff = b.value - a.value;
      const days = (b.date - a.date) / (24 * 60 * 60 * 1000);
      if (days <= 0) continue;

      if (a.month === b.month) {
        monthTotals[a.month] = (monthTotals[a.month] || 0) + diff;
      } else {
        const monthStart = new Date(a.month + '-01');
        const nextMonthStart = new Date(monthStart);
        nextMonthStart.setMonth(nextMonthStart.getMonth() + 1);
        const firstMonthDaysCnt = (nextMonthStart - a.date) / (24 * 60 * 60 * 1000);
        const secondMonthDaysCnt = days - firstMonthDaysCnt;

        monthTotals[a.month] = (monthTotals[a.month] || 0) + diff * (firstMonthDaysCnt / days);
        monthTotals[b.month] = (monthTotals[b.month] || 0) + diff * (secondMonthDaysCnt / days);
      }
    }

    const labels = Object.keys(monthTotals).filter(m => m.startsWith(year)).sort();
    const data = labels.map(m => monthTotals[m]);

    // Calculate total for year
    const yearTotal = data.reduce((sum, val) => sum + val, 0);

    // Get color for this year (reverse index since years are reversed)
    const colorIndex = years.length - 1 - yearIndex;
    const yearColor = yearColors[colorIndex % yearColors.length];

    // Create year section
    const yearSection = document.createElement('div');
    yearSection.style.marginTop = '15px';
    yearSection.style.borderLeft = `4px solid ${yearColor}`;
    yearSection.style.paddingLeft = '10px';

    // Year header
    const yearHeader = document.createElement('div');
    yearHeader.style.marginBottom = '8px';
    yearHeader.style.display = 'flex';
    yearHeader.style.justifyContent = 'space-between';
    yearHeader.style.alignItems = 'center';

    yearHeader.innerHTML = `
      <span style="font-weight:bold; color:${yearColor}; font-size:16px">
        ${year}
      </span>
      <span style="color:#aaa">
        Всього: <strong style="color:${yearColor}">${Math.round(yearTotal)}</strong>
      </span>
    `;

    // Chart container
    const chartWrap = document.createElement('div');
    chartWrap.style.position = 'relative';
    chartWrap.style.width = '100%';
    chartWrap.style.height = '200px';

    const canvas = document.createElement('canvas');
    canvas.id = `bar-${i}-${year}`;
    chartWrap.appendChild(canvas);

    yearSection.appendChild(yearHeader);
    yearSection.appendChild(chartWrap);
    barContainer.appendChild(yearSection);

    // Draw chart
    const ctx = canvas.getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels.map(m => m.slice(5)), // Show only MM
        datasets: [{
          label: `Споживання ${year}`,
          data,
          backgroundColor: `${yearColor}AA`
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: { padding: { bottom: 15 } },
        scales: {
          x: {
            grid: { color: '#2b2b2b' },
            ticks: { padding: 5, color: '#ddd' }
          },
          y: {
            grid: { color: '#2b2b2b' },
            ticks: { color: '#ddd' }
          }
        },
        plugins: {
          legend: {
            display: false
          }
        }
      },
      plugins: [deltaArrowsPlugin]
    });
  });
}

function updateStats(i, sorted, yearGroups, yearBaselines) {
  const statsBox = document.getElementById(`stats-${i}`);
  if (!sorted.length) { statsBox.innerHTML = ''; return; }

  const years = Object.keys(yearGroups).sort();
  let statsHTML = '';

  // Per-year stats
  years.forEach((year, idx) => {
    const yearEntries = yearGroups[year];
    const firstVal = yearEntries[0].value;
    const lastVal = yearEntries[yearEntries.length - 1].value;
    const yearGrowth = lastVal - yearBaselines[year];

    statsHTML += `<strong>${year}:</strong> ${Math.round(yearGrowth)} | `;
  });

  // Total growth
  const totalGrowth = sorted[sorted.length - 1].value - sorted[0].value;
  statsHTML += `<strong>Всього:</strong> ${Math.round(totalGrowth)}`;

  statsBox.innerHTML = statsHTML;
}

function renderDatasets() {
  const host = document.getElementById('datasets');
  host.innerHTML = '';
  datasets.forEach((ds, i) => {
    const card = document.createElement('div');
    card.className = 'dataset';
    card.innerHTML = `
      <h2>${ds.name}</h2>
      <button onclick="toggleCollapse(${i})">${ds.collapsed ? 'Розгорнути' : 'Згорнути'}</button>
      <div style="display:${ds.collapsed ? 'none' : 'block'};">
        <table>
          <thead><tr><th>#</th><th>Дата</th><th>Значення</th><th>Дії</th></tr></thead>
          <tbody>
            ${ds.entries.map((e,j) => `
              <tr>
                <td>${j+1}</td>
                <td><input type="date" value="${e.date || ''}" onchange="updateEntry(${i},${j},'date',this.value)"></td>
                <td><input type="number" value="${isNaN(e.value)?'':e.value}" onchange="updateEntry(${i},${j},'value',this.value)"></td>
                <td class="controls">
                  <button onclick="moveEntry(${i},${j},-1)">↑</button>
                  <button onclick="moveEntry(${i},${j},1)">↓</button>
                  <button onclick="deleteEntry(${i},${j})">Видалити</button>
                </td>
              </tr>`).join('')}
          </tbody>
        </table>
        <div style="margin-top:8px; display:flex; gap:8px; flex-wrap: wrap;">
          <button onclick="addEntry(${i})">Додати рядок</button>
          <button onclick="exportCSV(${i})">Експорт CSV</button>
          <label style="display:inline-flex; align-items:center; gap:.5rem; cursor:pointer;">
            <span style="padding:6px 10px; background:var(--btn); border:1px solid var(--muted); border-radius:4px;">Імпорт CSV</span>
            <input type="file" accept=".csv" style="display:none" onchange="importCSV(event,${i})">
          </label>
        </div>
      </div>
      <div class="stats" id="stats-${i}"></div>
      <div class="chart-wrap"><canvas id="chart-${i}"></canvas></div>
      <div id="bar-container-${i}"></div>
    `;
    host.appendChild(card);
    drawChart(i);
  });
}

renderDatasets();
</script>
</body>
</html>
